-- Supabase Schema for Fetal Kick Tracker
-- Run this in Supabase SQL Editor to create necessary tables

-- Enable Row Level Security
ALTER TABLE kick_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE kick_records ENABLE ROW LEVEL SECURITY;

-- Create kick_settings table (if not exists)
CREATE TABLE IF NOT EXISTS kick_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    due_date DATE,
    vibrate BOOLEAN DEFAULT true,
    baby_name TEXT,
    baby_style TEXT DEFAULT 'cartoon',
    baby_icon TEXT DEFAULT 'üë∂üèª',
    baby_custom_image TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()),
    UNIQUE(user_id)
);

-- Create kick_records table (if not exists)
CREATE TABLE IF NOT EXISTS kick_records (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    record_date DATE NOT NULL,
    record_time TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW())
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_kick_settings_user ON kick_settings(user_id);
CREATE INDEX IF NOT EXISTS idx_kick_records_user ON kick_records(user_id);
CREATE INDEX IF NOT EXISTS idx_kick_records_date ON kick_records(user_id, record_date);

-- RLS Policies for kick_settings
-- Users can only access their own settings
DROP POLICY IF EXISTS "Users can CRUD their own settings" ON kick_settings;
CREATE POLICY "Users can CRUD their own settings" ON kick_settings
    FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- RLS Policies for kick_records
-- Users can only access their own records
DROP POLICY IF EXISTS "Users can CRUD their own records" ON kick_records;
CREATE POLICY "Users can CRUD their own records" ON kick_records
    FOR ALL
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Enable anonymous access for testing (optional)
-- Uncomment if you want to allow anonymous sign-ins
-- ALTER TABLE kick_settings ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE kick_records ENABLE ROW LEVEL SECURITY;

-- Anonymous users policy (if using anonymous sign-ins)
DROP POLICY IF EXISTS "Anonymous users can access their own data" ON kick_settings;
CREATE POLICY "Anonymous users can access their own data" ON kick_settings
    FOR ALL
    USING (auth.uid() = user_id OR auth.uid() IN (
        SELECT id FROM auth.users WHERE is_anonymous = true
    ))
    WITH CHECK (auth.uid() = user_id OR auth.uid() IN (
        SELECT id FROM auth.users WHERE is_anonymous = true
    ));

DROP POLICY IF EXISTS "Anonymous users can access their own records" ON kick_records;
CREATE POLICY "Anonymous users can access their own records" ON kick_records
    FOR ALL
    USING (auth.uid() = user_id OR auth.uid() IN (
        SELECT id FROM auth.users WHERE is_anonymous = true
    ))
    WITH CHECK (auth.uid() = user_id OR auth.uid() IN (
        SELECT id FROM auth.users WHERE is_anonymous = true
    ));

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger for kick_settings
DROP TRIGGER IF EXISTS update_kick_settings_updated_at ON kick_settings;
CREATE TRIGGER update_kick_settings_updated_at
    BEFORE UPDATE ON kick_settings
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Trigger for kick_records
DROP TRIGGER IF EXISTS update_kick_records_updated_at ON kick_records;
CREATE TRIGGER update_kick_records_updated_at
    BEFORE UPDATE ON kick_records
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Grant permissions (Supabase handles this automatically for auth.users)
-- But we need to ensure the tables can be accessed
GRANT ALL ON kick_settings TO postgres, anon, authenticated, service_role;
GRANT ALL ON kick_records TO postgres, anon, authenticated, service_role;
GRANT USAGE, SELECT ON SEQUENCE kick_settings_id_seq TO postgres, anon, authenticated, service_role;
GRANT USAGE, SELECT ON SEQUENCE kick_records_id_seq TO postgres, anon, authenticated, service_role;

SELECT 'Schema setup complete!' as status;
